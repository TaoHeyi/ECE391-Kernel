/* rtc.c - functions for real time clock
 * vim:ts=4 noexpandtab
 */

#include "rtc.h"

/* Interrupt flag for whether an interrupt has received */
int rtc_interrupt_received;

/****************** Part 1 RTC functions start here ******************/

/* void rtc_init(void)
 * Input:  none
 * Return Value: none
 * Function: Initialize rtc, and its status register. 
 * enable irq8 on PIC, turns on periodic interrupt and set default frequency to 1024Hz. */
void rtc_init(void)
{
    // Initialization code, from https://wiki.osdev.org/RTC
    outb(RTC_REG_B, RTC_INDEX);	        // select register B, and disable NMI
    char prev = inb(RTC_DATA);	        // read the current value of register B
    outb(RTC_REG_B, RTC_INDEX);	        // set the index again (a read will reset the index to register D)
    outb(prev | 0x40, RTC_DATA);        // write the previous value ORed with 0x40. This turns on bit 6 of register B

    enable_irq(RTC_IRQ);                //enable irq8
    
    /* For vitualizing the RTC, always 1024Hz */
    rtc_set_freq(1024);                 
}

/* void rtc_interrupt_handler(void)
 * Input:  none
 * Return Value: none
 * Function: called when an interrupt is generated by RTC. 
 * send eoi, call test_interrupt as required, and allow future interrupt. */
void rtc_interrupt_handler(void)
{
    send_eoi(RTC_IRQ);          //end of interrupt, send eoi
    
    //test_interrupts();          //as required by doc

    int i;
    
    /* Decrement counter in each terminal */
    for(i = 0; i < TERM_MAX; i++){
        /* Obtain the current PCB */
        pcb_t* cur_pcb = get_pcb_from_id(term[i].cur_pcb_id + i*MAX_PCB_MASK_LEN);
        if(cur_pcb->rtc_counter > 0) cur_pcb->rtc_counter--;
    }

    // Read from RTC register C at end of interrupt to receive future interrupt
    outb(RTC_REG_C, RTC_INDEX); // select register C
    inb(RTC_DATA);		        // just throw away contents
}

/* void rtc_set_freq(int freq)
 * Input:  none
 * Return Value: none
 * Function: Set freq to own value; note that freq = (2^15 >> (rate - 1)), 
 * rate is the value we sent to reg A, so that it change the frequency. */
void rtc_set_freq(int freq)
{
    uint8_t rate = 0x01;        //rate value that will be sent to register A

    if(freq==32768) return;

    while(freq<32768){      //32768 is 2^15
        freq*=2;
        rate+=0x01;
    }

    outb(RTC_REG_A,RTC_INDEX);          // select register A, and disable NMI
    char prev = inb(RTC_DATA);          // read the current value of register A
    outb(RTC_REG_A,RTC_INDEX);          // set the index again (a read will reset the index to register D)
    outb((prev&0xF0) | rate, RTC_DATA); //change the freq by sending rate to register A
}

/****************** Part 2 RTC functions start here ******************/

/* int32_t rtc_open(const uint8_t* filename)
 * Input: pointer to filename, ignored in this case
 * Return Value: none
 * Function: Set freq to 2HZ; note that freq = (2^15 >> (rate - 1)) */
int32_t rtc_open(const uint8_t* filename)
{   
    /* Obtain the current PCB */
    pcb_t* cur_pcb = get_pcb_from_id(term[now_term_id].cur_pcb_id + now_term_id*MAX_PCB_MASK_LEN);

    /* Virtualize the frequency to 2 and counter to 1024 / 2 for process */
    cur_pcb->rtc_freq = 2;
    cur_pcb->rtc_counter = 1024 / (cur_pcb->rtc_freq);;
    return 0;
}

/* int32_t rtc_close(int32_t fd)
 * Input:  pointer to the file descriptor
 * Return Value: none
 * Function: close the file */
int32_t rtc_close(int32_t fd)
{   
    return 0;
}

/* int32_t rtc_read(int32_t fd, void* buf, int32_t nbytes)
 * Input: fd -- file descriptor, ignored in this case
 *        buf -- pointer to buffer, ignored in this case
 *        nbytes -- number of bytes to be written, ignored in this case
 * Return Value: always 0
 * Function: Read the RTC once an interrupt is generated */
int32_t rtc_read(int32_t fd, void* buf, int32_t nbytes)
{
    sti();

    /* Obtain the current PCB */
    pcb_t* cur_pcb = get_pcb_from_id(term[now_term_id].cur_pcb_id + now_term_id*MAX_PCB_MASK_LEN);

    /* Set the counter to max freq / cur freq */
    cur_pcb->rtc_counter = 1024 / (cur_pcb->rtc_freq);

    /* Wait if one cycle has not finished */
    while(cur_pcb->rtc_counter > 0);

    return 0;
}

/* int32_t rtc_write(int32_t fd, void* buf, int32_t nbytes)
 * Input: fd -- file descriptor, ignored in this case
 *        buf -- pointer to buffer, contains the frequency to be set
 *        nbytes -- number of bytes to be written
 * Return Value: 0 if success and -1 if failure
 * Function: Set freq to number specified, can only be power of 2 */
int32_t rtc_write(int32_t fd, const void* buf, int32_t nbytes)
{   
    /* Check for null ptr */
    if(buf == NULL) return -1;

    /* Cast buf into integer pointer and dereference for freq */
    int freq = *((int*)buf);

    /* Obtain the current PCB */
    pcb_t* cur_pcb = get_pcb_from_id(term[now_term_id].cur_pcb_id + now_term_id*MAX_PCB_MASK_LEN);

    /* Check if freq is power of 2 and less than or equal to 1024 and nbytes is 4 and freq > 1 */
    if((freq && !(freq & (freq-1))) && (freq <= 1024) && (nbytes == 4) && (freq > 1)){
        cur_pcb->rtc_freq = freq;
        return 0;
    }
    /* Return -1 indicating write failure */
    else return -1;
}
